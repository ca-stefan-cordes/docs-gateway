= Install and Run Flex Gateway
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

Flex Gateway runs in many different environments, including Docker, Ubuntu, and Kubernetes (as an application and as an ingress controller). This document describes how to install and run Flex Gateway in each of these environments.

[cols="1,1,1,1"]
|===

|image:install-docker-logo.png[25%,25%,xref="microgateway-install-run.adoc#install-and-run-as-a-docker-container-image"]

|image:install-ubuntu-logo.png[20%,20%,xref="microgateway-install-run.adoc#install-and-run-as-an-ubuntu-service"]

|image:install-kubernetes-logo.png[20%,20%,xref="microgateway-install-run.adoc#install-and-run-as-a-kubernetes-application"]

|image:install-kubernetes-logo.png[20%,20%,xref="microgateway-install-run.adoc#install-and-run-as-a-kubernetes-ingress-controller"]

|xref:microgateway-install-run.adoc#install-and-run-as-a-docker-container-image[Install and Run as a Docker Container Image]

|xref:microgateway-install-run.adoc#install-and-run-as-an-ubuntu-service[Install and Run as an Ubuntu Service in a VM]

|xref:microgateway-install-run.adoc#install-and-run-as-a-kubernetes-application[Install and Run as a Kubernetes Application]

|xref:microgateway-install-run.adoc#install-and-run-as-a-kubernetes-ingress-controller[Install and Run as a Kubernetes Ingress Controller]

|===

== Install and Run as a Docker Container Image

A Docker container image is a package of software that includes everything needed to run an application. You install and run Flex Gateway as a container image in your local environment during application development - enabling you to test and iterate quickly within Continuous-Integration and Continuous Delivery (CI/CD) workflows. 

The following procedure demonstrates how to install and run a "containerized" Flex Gateway in your local environment.

=== Before You Begin

Installation requires a Docker-enabled environment with appropriate Docker permissions. See https://docs.docker.com/compose/install/[Install Docker Compose^].

=== Procedure

. https://drive.google.com/file/d/1xR2kQqV5BUdIqk8LUbdW8LSdjlF2dP8P/view?usp=sharing[Download the Flex Gateway container image^].
. Copy the container image tar archive into a directory of your choice.
. Open a command line client and navigate to the directory containing the container image tar archive.
. Install the Flex Gateway container image by executing the following command:
+
----
docker load --input peregrine.tar
----

. Verify the installation was successful by executing the following command: 
+
----
docker images
----
+
The Flex Gateway container image should appear in the resulting list: 
+
----
REPOSITORY                      TAG       IMAGE ID       CREATED        SIZE
mulesoft/peregrine              latest    1c1fbdbf819b   9 days ago     279MB
----

. https://drive.google.com/file/d/1Uq1YA8UZCRCLhmg7-nMsUPjafNjFzAPQ/view?usp=sharing[Download the sample Flex Gateway configuration file^].
. Copy the sample configuration `.yaml` file into a directory of your choice (typically the same directory as the container image tar archive.)
. Run Flex Gateway by executing the following command: 
+
----
docker run -it -p 8080:8080 -v /absolute/path/to/app.yaml:/etc/peregrine/conf.d/custom/app.yaml mulesoft/peregrine
----

. Verify that the container image is running successfully by executing the following command: 
+
----
docker ps
----
+
The Flex Gateway process should appear in the resulting list: 
+
----
CONTAINER ID   IMAGE                    COMMAND   CREATED      STATUS      PORTS                                       
c2a360f8c9ed   mulesoft/peregrine       "/init"   8 days ago   Up 8 days   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp 
----

== Install and Run as an Ubuntu Service

In addition to sandboxing Flex Gateway as a Docker container image, you can install and run Flex Gateway as an Ubuntu service. The Ubuntu instance is typically run virtually as a node in a virtual machine cluster, thereby guaranteeing that each virtual machine (with its running Flex Gateway) is standalone and encapsulated. 

The following procedure demonstrates how to install and run Flex Gateway as a service in an Ubuntu instance.

=== Procedure

. Retrieve the public package keys and add them to the Advanced Package Tool (APT) key server by executing the following command:
+ 
----
curl -XGET https://peregrine:48bcfd4617c9cce@d8wbbsqfcfi8u.cloudfront.net/ubuntu/pubkey.gpg | sudo apt-key add -
----

. Add the Flex Gateway package repository by storing the type of distribution archive (Debian), as well as the repository URL and Ubuntu distribution code name. Execute the following command: 
+
----
echo "deb https://peregrine:48bcfd4617c9cce@d8wbbsqfcfi8u.cloudfront.net/ubuntu $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/mulesoft.list
----

. Update the package list by executing the following command: 
+
----
sudo apt update
----

. Install the Flex Gateway package from the updated repository by executing the following command:
+
----
sudo apt install peregrine
----

. Run the Flex Gateway by executing the following command:
+
----
sudo service peregrine start
----

. Verify that the Flex Gateway service is running successfully by executing the following command: 
+
----
service --status-all
----
+
A list of all services displays. Locate the `peregrine` service, which will be successfully running if the value of its `status` is `+`, as in the following:   
+
----
[ + ]  peregrine
----

== Install and Run as a Kubernetes Application

The following procedure demonstrates how to install and run Flex Gateway as an application running in a Kubernetes cluster.

=== Procedure

. Install Flex Gateway.
+
You can execute `docker load` and then `docker push` to a registry (you can host a private registry in Kubernetes or use a public one).

. Run Flex Gateway:
+
----
kubectl create deployment <...>
----

. Verify that the Flex Gateway service is running successfully. 
.. View the deployment: 
+
----
kubectl get deployments
----
+
The output is similar to: 
+
----
NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
peregrine               1/1     1            1           1m
----
+
.. View the Pod: 
+
----
kubectl get pods <...>
----
+
The output is similar to: 
+
----
NAME                                     READY     STATUS    RESTARTS   AGE
peregrine-5f76cf6ccf-br9b5               1/1       Running   0          1m
----

== Install and Run as a Kubernetes Ingress Controller

You can install Flex Gateway as an Ingress controller - a specialized Kubernetes application that routes external traffic to internal applications and services. The following procedures demonstrate how to install and run Flex Gateway as an Ingress controller. Installation phases are divided by typical roles: 

* An Infrastructure Provider adds the Flex Gateway repository to the cluster, and adds supporting platform components, such as the Grafana repository.
* A Cluster Operator configures cluster-specific functionality such as local storage and logging. 
* An API Administrator secures services by applying polices. 
* An Application Developer builds the containerized apps driven by business requirements.

=== Dependencies

* https://docs.docker.com/compose/install/[Docker,^] a platform that delivers applications in packages called containers.
* https://k3d.io/v5.0.0/#installation[K3d,^] a tool used to create Kubernetes clusters.
* https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl,^] a tool used to interact with Kubernetes clusters.
* https://helm.sh/docs/intro/install/[Helm,^] a tool used to install Peregrine, monitoring tools and applications.

=== Prepare the Environment

. Create a new Kubernetes cluster with a single server node: 
+
----
k3d cluster create demo-milestone3 --k3s-arg "--disable=traefik@server:0" --port '80:80@server:0'
----
+
The command should return the following: 
+
----
INFO[0042] Cluster 'demo-milestone3' created successfully!
----

. https://drive.google.com/file/d/1eFxLbBIHHgOxL8XnVmBhwYzom1Xd-gfT/view?usp=sharing[Download the Flex Gateway container^] and import the Docker image: 
+
----
k3d image import -c demo-milestone3 peregrine.tar
----
+
The command should return the following: 
+
----
INFO[0016] Successfully imported image(s)
INFO[0016] Successfully imported 1 image(s) into 1 cluster(s)
----

=== Procedure: As the Infrastructure Provider

. Add the Flex Gateway and Grafana `helm` repositories: 
+
----
helm repo add grafana https://grafana.github.io/helm-charts \
    && helm repo add peregrine https://peregrine:48bcfd4617c9cce@d8wbbsqfcfi8u.cloudfront.net/helm \
    && helm repo up
----
+
The command should return the following: 
+
----
"grafana" has been added to your repositories
"peregrine" has been added to your repositories
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "peregrine" chart repository
...Successfully got an update from the "grafana" chart repository
Update Complete. ⎈Happy Helming!⎈
----

. https://drive.google.com/file/d/1oDHbwk46TsdO_GaJIefo8fAMFf7CDhYV/view?usp=sharing[Download the "grafana-values.yaml" file^] and configure Grafana:
+
----
helm -n monitoring upgrade -i --wait --create-namespace grafana grafana/grafana -f grafana-values.yaml
----

. Verify that Grafana is running: 
+
----
kubectl --namespace monitoring port-forward svc/grafana 8080:80 &
open http://localhost:8080/
---- 
+
Log in to Grafana with the following credentials:
+ 
* username: admin 
* password: peregrine

. Install Loki (a log aggregator): 
+
----
helm -n monitoring upgrade -i --wait --create-namespace loki grafana/loki
----
+

. Install Flex Gateway as an Ingress Controller: 
+
----
helm -n gateway upgrade -i --wait --create-namespace ingress peregrine/peregrine --set image.name=mulesoft/peregrine,ingress.enabled=true
----
+
The command should return something like the following: 
+
----
NAME: ingress
LAST DEPLOYED: Tue Oct 19 13:08:07 2021
NAMESPACE: gateway
STATUS: deployed
REVISION: 1
TEST SUITE: None
----

. Verify that the Flex Gateway Ingress Controller is running:
+
----
kubectl -n gateway get svc,apiinstances
---- 
+
The command returns output similar to the following: 
+
----
NAME              TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE
service/ingress   LoadBalancer   10.43.64.139   172.19.0.3    80:30426/TCP,443:31828/TCP   118s

NAME                                             ADDRESS
apiinstance.gateway.mulesoft.com/ingress-https   http://0.0.0.0:443/
apiinstance.gateway.mulesoft.com/ingress-http    http://0.0.0.0:80/
----

. Forward the Ingress port to `localhost`: 
+
----
kubectl --namespace gateway port-forward svc/ingress 8000:80
----
+
The Ingress is now awaiting connections.

. Open a new shell and verify that the URL and port are accessible: 
+
----
curl -v http://localhost:8000/
----
+
The command should return a `404 Not Found` error because an application listening at that address hasn't yet been deployed.

=== Procedure: As the Cluster Operator

. Configure local storage for policies that share data: 
+
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Configuration
metadata:
 name: shared-storage
 namespace: gateway
spec:
 sharedStorage:
   local:
     enabled: true
EOF
----

. Forward (output) both the `runtimeLogs` and `accessLogs` logging objects to Loki, for viewing in Grafana: 
+
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Configuration
metadata:
  name: logging
  namespace: gateway
spec:
  logging:
    outputs:
    - name: loki
      type: loki
      parameters:
        host: loki.monitoring.svc
        port: "3100"
        labels: job=peregrine,instance=\${HOSTNAME},kind=\$kind,loglevel=\$loglevel,runtime=\$runtime
    runtimeLogs:
      logLevel: info
      outputs:
      - loki
    accessLogs:
      outputs:
      - loki
EOF
----

=== Procedure: As the API Administrator

. Apply the `access-log` policy to the  `ingress-http` `ApiInstance`, for viewing in Grafana: 
+
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: PolicyBinding
metadata:
  name: ingress-http-access-log
  namespace: gateway
spec:
  targetRef:
    kind: ApiInstance
    name: ingress-http
  policyRef:
    kind: Extension
    name: access-log
  config: {}
EOF
----

. Apply the `rate-limit-local` policy to the `ingress-http` `ApiInstance`: 
+
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: PolicyBinding
metadata:
  name: ingress-http-ratelimit
  namespace: gateway
spec:
  targetRef:
    kind: ApiInstance
    name: ingress-http
  policyRef:
    kind: Extension
    name: rate-limit-local
  config:
    headers: true
    tiers:
    - timePeriod: 2
      maximumRequests: 1
      timeUnit: SECONDS
    - timePeriod: 1
      maximumRequests: 30
      timeUnit: MINUTES
EOF
----

=== Procedure: As the Application Developer

. Install the `httpbin` application, and create an ingress that routes traffic from `/httpbin/` to the `ingress-http` `ApiInstance` in namespace `gateway`:  
+
----
helm -n default upgrade -i --wait --create-namespace httpbin peregrine/httpbin --set ingress.enabled=true,ingress.name=ingress-http.gateway
----
+
The command should return something like the following:toc:
+
----
NAME: httpbin
LAST DEPLOYED: Tue Oct 19 13:27:17 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
----

. Install the `whoami` application, and create an ingress that routes traffic from `/whoami/`` to the `ingress-http` `ApiInstance` in namespace `gateway`: 
+
----
helm -n default upgrade -i --wait --create-namespace whoami peregrine/whoami --set ingress.enabled=true,ingress.name=ingress-http.gateway
----

. Verify that the `whoami` application is running: 
+
----
curl -v http://localhost:8000/whoami/get 
----
+
The command returns the following headers, as added by the `rate-limit` policy: 
+
----
< HTTP/1.1 200 OK
< x-ratelimit-remaining: 0
< x-ratelimit-limit: 1
< x-ratelimit-reset: 2000
----

. Luanch the Grafana dashboard to view the Flex Gateway logs:
+
----
open http://localhost:8080/d/WMcWrCv7k/peregrine
----

. Run the following Grafana Explorer queries to view logs: 
+
* Runtime logs
+
----
{job="peregrine",kind="runtimeLog"} | json | line_format "{{.runtime}} {{.loglevel}} {{.message}}"
----
+
* Access logs
+
----
{job="peregrine",kind="accessLog"} | json | line_format "{{.message}}" | json
----
+
* Query per seconds, by status code
+
----
sum by (status_code) (rate({job="peregrine",kind="accessLog"} | json | line_format "{{.message}}" | json [5m]))
----

. Verify that the `httpbin` application is running: 
+
----
curl -v http://localhost:8080/httpbin/headers
----