= Flex Gateway Resource Sizing
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images
:table-caption!:

This document provides recommendations for sizing Flex Gateway resources. As the bridge between your application and backend services, Flex Gateway plays a critical role in managing and controlling the interactions between these components. It is therefore important to size your resources appropriately to ensure optimal performance and reliability.

The recommendations are guidelines only. Additional benchmarking adjustments should be performed to satisfy specific performance requirements.

The most important factor for right sizing gateways indicates that it should be based on the number of APIs deployed and policies applied. All scenarios that we used ended up using more memory while deploying apps. Our sizing exercise takes that into consideration and as observed in the Evidence section is the main factor for sizing. Steady state utilization of resources (when load is being applied) was significantly less than the resources needed to set up flex gateway.

The following five configurations describe baseline performance against given specifications.

== 20 APIs, 200 Users

In this use case, Flex Gateway running in Kubernetes deployments has computing limits set at cpu=2000m, memory=2Gi, and request limits set at cpu=250m, memory=512Mi. It uses two replicas. 20 APIs have been deployed, with a load distributed among 200 users, handling 100 transactions per second.

.Message Logging and JWT Validation policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Rate Limiting policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Header Injection policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

== 100 APIs, 200 Users

This scenario has a gateway with computing settings in kubernetes-deployments limits for cpu=2cores, memory=2GiB and requests cpu=250m, memory=512MiB and replica=2. The test will be to deploy in this gateway 100 APIs distributed load in 200 users and 200 transactions per second.

.Message Logging and JWT Validation policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|200
|202
|0.163
|712

|3
|1kb
|200
|202
|0.138
|702

|2
|100kb
|200
|203
|0.184
|713

|3
|100kb
|200
|204
|0.159
|714
|===

.Message Logging and Rate Limiting policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Header Injection policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

== 200 APIs, 200 Users

This scenario has a gateway with computing settings in kubernetes-deployments limits for cpu=2cores, memory=4Gi and requests cpu=0.250, memory=512MiB and replica=2. The test will be to deploy in this gateway 200 APIs distributed load in 200 users and 200 transactions per second.

.Message Logging and JWT Validation policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|200
|202
|0.163
|712

|3
|1kb
|200
|202
|0.138
|702

|2
|100kb
|200
|203
|0.184
|713

|3
|100kb
|200
|204
|0.159
|714
|===

.Message Logging and Rate Limiting policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Header Injection policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

== 400 APIs, 500 Users

This scenario has a gateway with computing settings in kubernetes-deployments limits for cpu=2, memory=8GiB  and requests cpu=0.250, memory=512MiB and replica=2. The test will be to deploy in this gateway 400 APIs distributed load in 500 users and 500 transactions per second.

.Message Logging and JWT Validation policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|200
|202
|0.163
|712

|3
|1kb
|200
|202
|0.138
|702

|2
|100kb
|200
|203
|0.184
|713

|3
|100kb
|200
|204
|0.159
|714
|===

.Message Logging and Rate Limiting policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Header Injection policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

== 500 APIs, 1000 Users

This scenario has a gateway with computing settings in kubernetes-deployments limits for cpu=2, memory=12GiB and requests cpu=250m, memory=512MiB  and replica=2. The test will be to deploy in this gateway 500 APIs distributed load in 1000 users and 200 transactions per second.

.Message Logging and JWT Validation policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|200
|202
|0.163
|712

|3
|1kb
|200
|202
|0.138
|702

|2
|100kb
|200
|203
|0.184
|713

|3
|100kb
|200
|204
|0.159
|714
|===

.Message Logging and Rate Limiting policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===

.Message Logging and Header Injection policies applied:
[cols="1a,1a,1a,1a,1a,1a"]
|===
|Pods |Response Size |Throughput |Average Response Time |Average CPU Usage |Average Memory Used (MIB)

|2
|1kb
|104
|205
|0.074
|500.5

|3
|1kb
|93.2
|204
|0.064
|519

|2
|100kb
|100
|206
|0.0854
|524

|3
|100kb
|80.4
|206
|0.0707
|517
|===